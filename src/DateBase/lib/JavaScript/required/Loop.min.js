class Client {
    constructor (id, websocket, user, loop) {
        this.id         = id;
        this.websocket  = websocket;
        this.user       = user;

        this.loop       = loop;
    }

    message(json) {
        if (!json || !json.event || !this.loop.events || !this.loop.events[json.event]) {
            return this.user.send('error', { type: 1004, id: json.id });
        }

        var event = this.loop.events[json.event];

        this.a(event, json.data, json.id);
    }

    a(event, data, id) {
        if (!this.queue) {
            this.queue = [];
        }

        this.queue.push({ event: event, data: data, id: id });

        this.c();
    }

    resolve(data) {
        return new Promise(async (resolve, rejects) => {
            setTimeout(() => { rejects({ id: data.id, type: 1006 }); }, (data.event.param ? data.event.param.timeout : undefined) || 5000);

            try {
                await data.event.func(this.user, this, data.data || {}, data.id);                
            } catch (e) {
                return rejects({ id: data.id, type: 1005, error: e.message });
            }

            return resolve();
        });
    }

    async b() {
        if (!this.started) {
            this.started = true;
        }

        while (this.started) {
            await this.resolve(this.queue.shift()).catch(_ => {
                this.user.send('error', _)
            }).then(() => {

            });

            if (!this.queue || this.queue.length == 0) {
                this.started = false;
            }
        }
    }

    c() {
        if (this.started) {
            return
        }

        this.started = true;
        this.b();
    }
}

const fs = require('fs');

exports.Loop = class {
    constructor(Index) {
        this.index   = Index;

        this.Clients = {};

        if (!this.modules()) {
            Log.error(`Aucun modules trouv√©`);
        };
    }

    modules() {
        var p = `${path}/lib/Events/`;

        if (!fs.existsSync(p)) {
            fs.mkdirSync(p, { recursive: true });

            return false;
        }

        this.events = {};

        for (var file of fs.readdirSync(p, { recursive: true })) {
            if (file.endsWith('.js')) {
                var module = require(`${p}/${file}`);
                if (module && module.info && module.info && this.events) {
                    for (var name of Object.keys(module.info)) {
                        if (module.info[name] && module.info[name].version && module.info[name].func) {
                            this.events[name] = { name: name, version: module.info[name].version, func: module.info[name].func, param: module.info[name].options };
                        }
                    }
                }
                delete require.cache[require.resolve(`${p}/${file}`)];
            }
        }

        if (Object.keys(this.events).length == 0) {
            return false;
        }

        return true;
    }

    add_Client(id, websocket, user) {
        this.Clients[id] = new Client(id, websocket, user, this);
    }

    Client(id) {
        return this.Clients[id];
    }

    del_Client(id) {
        if (this.Clients[id]) {
            delete this.Clients[id];
        }
    }
}