const { AES, CryptoJS } = require('../JavaScript/modules/aes.js');
const Zlib              = require('zlib');
const fs                = require('fs');

/**
 * @param {string} S
 * @returns {String}
**/
function decompressString(S) {
    let a = Buffer.from(S, 'base64').toString("utf8");

    let b = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
        b[i] = a.charCodeAt(i);
    }

    let c = Zlib.inflateSync(b);
    
        let m = "";
    for(i=0;i<c.length;i++){
        m += String.fromCharCode(c[i]);
    }
    
    a = null;
    b = null;
    c = null;
 
    return m;
}

/**
 * @param {string} S
 * @returns {String}
**/
function compressString(S) {
    let a = S.split('').map(x => x.charCodeAt(0));

    let b = Zlib.deflateSync(new Uint8Array(a));

    let c = '';
    for (let i = 0; i < b.length; i++) {
        c += String.fromCharCode(b[i]);
    }

    a = null;
    b = null;

    return Buffer.from(c, 'utf8').toString("base64");
}



function RandomChar(length) {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let result = "";
    const charsLength = chars.length;

    for (let i = 0; i < length; i++) {
        const randomIndex = Math.floor(Math.random() * charsLength);
        result += chars[randomIndex];
    }

    return result;
}

function open_db(User, path, level = 0) {
    const indexPath = `${globalThis.path}/common/Json/${path}/index.json`;

    if (typeof path !== 'string' || !fs.existsSync(indexPath)) {
        return 1101;
    }

    let index;
    try {
        index = JSON.parse(fs.readFileSync(indexPath, 'utf8'));
    } catch (e) {
        Log.error(`L'utilisateur "${User.id}" a rencontré une erreur lors de l'ouverture de la base de données "${path}".`);
        return 1103;
    }

    if (!index || !index.key || !index.files) {
        Log.error(`La base de données "${path}" est corrompue.`);
        return 5001;
    }

    if (index.level && index.level > level) {
        return 1203;
    }

    let decoded_string;
    try {
        const encoded_strings = index.files.map(file => fs.readFileSync(`${globalThis.path}/common/Json/${path}${file}`, 'utf8'));
        const decrypted_data = encoded_strings.map(file_content => AES.decrypt(file_content, index.key).toString(CryptoJS.enc.Utf8));
        decoded_string = decompressString(decrypted_data.join(''));
    } catch (e) {
        Log.error(`La base de données "${path}" est corrompue. Erreur: ${e.message}`);
        return 1104;
    }

    index = null;

    return decoded_string;
}

exports.open_db = open_db;

function save_db(path, data, level = 0) {
    const indexPath = `${globalThis.path}/common/Json/${path}/index.json`;

    if (typeof path !== 'string' || typeof data !== 'string' || !fs.existsSync(indexPath)) {
        return 1101;
    }

    let index;
    try {
        index = JSON.parse(fs.readFileSync(indexPath, 'utf8'));
    } catch (e) {
        Log.error(`L'utilisateur "${User.id}" a rencontré une erreur lors de l'ouverture de la base de données "${path}".`);
        return 1103;
    }

    if (!index || !index.key) {
        Log.error(`La base de données "${path}" est corrompue.`);
        return 5001;
    }

    if (index.level && index.level > level) {
        return 1203;
    }

    let compresed_data;
    try {
        compresed_data = compressString(data);
    } catch {
        return 1105;
    }

    const max_length = 1000000;
    const hash = [];
    for (let i = 0; i < compresed_data.length; i += max_length) {
        hash.push(compresed_data.substr(i, max_length));
    }

    if (!fs.existsSync(`${globalThis.path}/common/Json/${path}/files/`)) {
        fs.mkdirSync(`${globalThis.path}/common/Json/${path}/files/`);
    }

    const before_files = index.files;
    index.files = hash.map((_, i) => `/files/${i}.json`);

    hash.forEach((hashPart, i) => {
        const encoded_string = AES.encrypt(hashPart, index.key).toString();
        fs.writeFileSync(`${globalThis.path}/common/Json/${path}/files/${i}.json`, encoded_string, 'utf8');
    });

    if (before_files) {
        before_files.forEach(file => {
            if (!index.files.includes(file)) {
                fs.unlinkSync(`${path}${file}`);
            }
        });
    }

    try {
        fs.writeFileSync(indexPath, JSON.stringify(index, undefined, 4), 'utf8');
    } catch (e) {
        Log.error(`La base de données "${path}" est corrompue. Erreur: ${e}`);
        return 1104;
    }

    index = null;
    compresed_data = null;

    return { saved: true };
}

exports.save_db = save_db;


/**
 * 
 * @param {Events} event 
 * @param {Loop} _
 * @returns { Json }
 */
function ls(event, _) {
    const Clients = event.Clients;
    const Path    = `${Clients.path}/common/Json`;
    const Data    = event.data.data;

    var path      = Path + ( Data.path ? `/${Data.path}/` : '' );

    if (!fs.existsSync(path)) {
        return { error: `Le dossier demander n'a pas été trouver.` };
    }

    var result    = [];
    for (var file of fs.readdirSync(path)) {
        var stats = fs.statSync(`${path}/${file}`);
        if (stats.isDirectory() && fs.existsSync(`${path}/${file}/index.json`)) {
            try {
                var index_file = JSON.parse(fs.readFileSync(`${path}/${file}/index.json`));

                if (!index_file.hidden || Data.hidden) {
                    result.push({ path: file, type: 'bdd' });
                }
            } catch {

            }
        } else if (stats.isDirectory() && !fs.existsSync(`${path}/${file}/index.json`)) {
            result.push({ path: file, type: 'folders' });
        }
    }

    return { data: result };
}

/**
 * @param {String} path 
 * @param {String} data 
 * @returns {(Number | Object)}
 */
function new_db(path, data = undefined, level = 1) {
    if (`string` != typeof path)                           return 1101;
    else if (`string` != typeof data && data != undefined) return 1104;
    else if (fs.existsSync(`${globalThis.path}/common/Json/${path}/index.json`))          return 1106;

    var info = {
        files: [],
        key: RandomChar(64),
        timestamp: new Date().getTime(),
        level: level
    }

    try {
        fs.mkdirSync(`${globalThis.path}/common/Json/${path}/files/`, { recursive: true });
        fs.writeFileSync(`${globalThis.path}/common/Json/${path}/index.json`, JSON.stringify(info, undefined, 4), 'utf8');
    } catch (e){
        Log.error(`Erreur lors de la création de la base de données "${path}". Erreur : ${e}`);

        return 1107;
    }

    if (data) {
        var save = save_db(path, data, level);

        if (typeof save === 'number') {
            return save;
        }
    }

    return { create: true };
}

exports.new_db = new_db;

function del_db(path, level = 0) {
    if (`string` != typeof path)                           return 1101;
    else if (!fs.existsSync(`${globalThis.path}/common/Json/${path}/index.json`)) return 1102;

    try {
        var index = JSON.parse(fs.readFileSync(`${globalThis.path}/common/Json/${path}/index.json`, 'utf8'));
    } catch {
        return 1103;
    }

    if (index.level && index.level > level) {
        return 1203;
    }

    for (var file of index.files) {
        fs.unlinkSync(`${path}/${file}`);
    }

    fs.unlinkSync(`${globalThis.path}/common/Json/${path}/index.json`);

    function remove(path) {
        if (fs.readdirSync(path).length == 0) {
            fs.rmdirSync(path);
            var p = path.split('/');
            while(p.pop()==''){};
            return remove(p.join('/'));
        } else {
            return true;
        }
    }
    
    return { delete: remove(`${globalThis.path}/common/Json/${path}/files/`) };
}

exports.del_db = del_db;

function exist_db(path) {
    if (`string` != typeof path) return 1101;

    if (!fs.existsSync(`${globalThis.path}/common/Json/${path}/index.json`)) {
        return false;
    } else {
        return true;
    }
}

exports.exist_db = exist_db;

class Save {
    constructor(User, Size, Path, id, PID, uid, level) {
        this.User = User;
        this.Size = Size;
        this.Path = Path;
        this.Id = id;
        this.PID = PID
        this.parts = {};
        this.uid = uid;
        this.l = level;
    }

    add_data(n, data, end = false) {
        if (!this.PID[n]) {
            this.User.send('error', { id: this.Id, type: 1111 });return;
        }
        this.parts[this.PID[n]] = data;

        delete this.PID[n];

        if (end) {
            const save = this.save();
            delete this.User.save[this.Id];
            return save;
        }

        this.User.send('save', { part: n, recevied: true, save: this.Id, id: this.uid });
    }

    td() {
        const a = Object.keys(this.parts).map(Number).sort((a, b) => a - b);
        return a.map(cle => this.parts[cle]).join('');
    }

    save() {
        return save_db(this.Path, this.td(), this.l);
    }
}

exports.info = {
    open: {
        version: '0.0.0.1',
        func: (User, Client, Data, Id) => {        
            if (!Client.login) {
                return User.send('error', { id: Id, type: 1201 });
            }

            if (typeof Data.path === "undefined") {
                return User.send('error', { id: Id, type: 1101 });
            }
        
            const result = open_db(User, Data.path, Client.level);
        
            if (typeof result === "number") {
                return User.send('error', { id: Id, type: result });
            }

            const maxPayload = 1000000;

            if (result.length > maxPayload) {
                const parts = Math.ceil(result.length / maxPayload);
                User.send('open', { id: Id, parts });

                for (let i = 0; i < result.length; i += maxPayload) {
                    const part = Math.ceil((i + maxPayload) / maxPayload);
                    User.send('open', { id: Id, part, data: result.substr(i, maxPayload)});
                }
            } else {
                User.send('open', { id: Id, data: result });
            }
        }
    },
    save: {
        version: '0.0.0.1',
        func: (User, Client, Data, Id) => {
            if (!Client.login) {
                return User.send('error', { id: Id, type: 1201 });
            }

            const { id, data, part, end, size, path } = Data;

            if (typeof id === "string" && typeof data === "string" && typeof part === "string") {
                if (!User.save || !User.save[id]) {
                    return User.send('error', { id: Id, type: 1109 });
                }

                const save = User.save[id];
                const ad = save.add_data(part, data, end || false);

                if (ad) {
                    if (typeof ad === 'number') {
                        return User.send('error', { id: Id, type: ad });
                    }
                    User.send('save', { id: Id, data: ad });
                }
            } else if (typeof id === "undefined" && typeof size === "number" && typeof path === "string") {
                if (!User.save) User.save = {};

                let newId = RandomChar(64);
                while (User.save[newId]) newId = RandomChar(64);

                const maxPayload = 1000000;
                let parts = Math.ceil(size / maxPayload);

                let parts_id = {};
                for (let i = 1; i < (parts + 1); i++) {
                    let id = RandomChar(32);
                    while (parts_id[id]) { id = RandomChar(32) }
                    parts_id[id] = i
                }

                User.save[newId] = new Save(User, size, path, newId, parts_id, Id, Client.level);
                
                User.send('save', { id: Id, save: newId, parts, parts_id, maxPayload});

                newId = null;parts = null;parts_id = null;i = null;
            } else {
                User.send('error', { id: Id, type: 1110 });
            }
        }
    },
    new_db: {
        version: '0.0.0.1',
        func: (User, Client, Data, Id) => {
            if (!Client.login) {
                return User.send('error', { id: Id, type: 1201 });
            }

            if (typeof Data.path === "undefined") {
                return User.send('error', { id: Id, type: 1101 });
            }

            let level = 1;
            if (typeof Data.level == "number") {
                if (Client.level < Data.level) {
                    return User.send('error', { id: Id, type: 1202 });
                }
                level = Data.level;
            }

            const result = new_db(Data.path, Data.data, level);

            if (typeof result === "number") {
                return User.send('error', { id: Id, type: result });
            }

            User.send('new_db', { id: Id, data: result });
        }
    },
    del_db: {
        version: '0.0.0.1',
        func: (User, Client, Data, Id) => {
            if (!Client.login) {
                return User.send('error', { id: Id, type: 1201 });
            }

            if (typeof Data.path === "undefined") {
                return User.send('error', { id: Id, type: 1101 });
            }

            const result = del_db(Data.path, Client.level);

            if (typeof result === "number") {
                return User.send('error', { id: Id, type: result });
            }

            User.send('del_db', { id: Id, data: result });
        }
    },
    exist_db: {
        version: '0.0.0.1',
        func: (User, Client, Data, Id) => {
            if (!Client.login) {
                return User.send('error', { id: Id, type: 1201 });
            }

            if (typeof Data.path === "undefined") {
                return User.send('error', { id: Id, type: 1101 });
            }

            const result = exist_db(Data.path);

            if (typeof result === "number") {
                return User.send('error', { id: Id, type: result });
            }

            User.send('exist_db', { id: Id, exist: result });
        }
    }
};
